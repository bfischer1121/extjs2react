import path from 'path'
import fs from 'fs-extra'
import _ from 'lodash'
import recast from 'recast'
import { namedTypes, visit } from 'ast-types'
import ExtJSClass from './ExtJSClass'

import {
  getConfig,
  readFile,
  writeFile,
  isDirectory,
  getFilesRecursively,
  getRelativePath,
  getAbsolutePath,
  getPathInTargetDirForSource,
  asyncForEach,
  copySourceFileToTargetDir,
  logError
} from './Util'

export default class SourceFile{
  static sourceDir = null

  classes = []
  imports = []

  importNamesByClassName = {}

  unknownAliases    = []
  unknownClassNames = []

  constructor(filePath, source){
    this.filePath  = filePath
    this.source    = source
    this.parseable = this._getMatches(/Ext\.define\(\s*['|"][^'|"]+['|"]/g).length > 0

    if(this.parseable){
      try{
        this.ast = recast.parse(source)
      }
      catch(e){
        throw `Error parsing source file (${filePath}): ${e}`
      }

      this.parseable = (this.toCode() === source)
      this.process()
    }
  }

  static async transpile(){
    let files       = getFilesRecursively(getConfig().sourceDir),
        unparseable = files.filter(file => !file.endsWith('.js')),
        js          = files.filter(file => file.endsWith('.js')).filter(file => file.endsWith('NonClinical.js')),
        sources     = []

    await asyncForEach(js, async file => {
      let source = new SourceFile(file, await readFile(file))
      source.parseable ? sources.push(source) : unparseable.push(file)
    })

    SourceFile.initContext(sources)

    await SourceFile.prepareTargetDirectory()
    unparseable.forEach(copySourceFileToTargetDir)

    await asyncForEach(sources, async source => {
      source.addImports()
      source.classes.forEach(cls => cls.process('items'))
      source.save()
      //source.missingFiles.forEach(className => logError(`Unknown file for class: ${className}`))
    })
  }

  static initContext(sources){
    SourceFile.classesByClassName = {}
    SourceFile.classNamesByAlias  = {}
    SourceFile.classRe            = []

    sources.forEach(source => {
      source.classes.forEach(cls => {
        SourceFile.classesByClassName[cls.className] = cls
        SourceFile.classNamesByAlias[cls.classAlias] = cls.className
        SourceFile.classRe.push(cls.getFileSearchRegExp())
      })
    })
  }

  static async prepareTargetDirectory(){
    let targetDir = getConfig().targetDir,
        infoPath  = getAbsolutePath(targetDir, 'extjs2react.json'),
        generator = null

    try{
      generator = fs.readJsonSync(infoPath).generator
    }
    catch(e){}

    if(isDirectory(targetDir) && generator !== 'extjs2react'){
      throw 'Cannot clear or write to a directory not generated by extjs2react'
    }

    await fs.emptyDir(targetDir)
    await fs.writeFile(infoPath, JSON.stringify({ generator: 'extjs2react' }, null, 2))
  }

  static getUnqualifiedClassName(className){
    let parts = className.split('.')
    return parts[parts.length - 1]
  }

  toCode(){
    return this.parseable ? recast.print(this.ast).code : this.source
  }

  save(){
    writeFile(getPathInTargetDirForSource(this.filePath), this.toCode())
  }

  async addImports(){
    let aliases    = this.getAliasesUsed(),
        classNames = this.getClassNamesUsed(),
        classes    = []

    aliases.forEach(alias => {
      let className = SourceFile.classNamesByAlias[alias]
      className ? classNames.push(className) : this.unknownAliases.push(alias)
    })

    classNames.forEach(className => {
      let cls = SourceFile.classesByClassName[className]
      cls ? classes.push(cls) : this.unknownClassNames.push(className)
    })

    classes = _.uniq(classes)

    let importNames = _.groupBy(classes, cls => SourceFile.getUnqualifiedClassName(cls.className))

    Object.keys(importNames).forEach(importName => {
      let classes = importNames[importName]

      classes.forEach((cls, i) => {
        this.importNamesByClassName[cls.className] = importName + (classes.length === 1 ? '' : (i + 1))
      })
    })

    let files     = _.groupBy(classes, cls => cls.source.filePath),
        filePaths = Object.keys(files).reverse(),
        extraLine = (this.imports.length === 0)

    this.imports = filePaths.map((filePath, i) => {
      let importNames = files[filePath].map(cls => this.importNamesByClassName[cls.className]),
          specifiers  = importNames.length > 1 ? '{ ' + importNames.join(', ') + ' }' : importNames[0],
          source      = getRelativePath(this.filePath, filePath).replace(/\.js$/, ''),
          suffix      = (extraLine && i + 1 === filePaths.length) ? '\n\n' : '\n'

      return recast.parse(`import ${specifiers} from '${source}'${suffix}`).program.body[0]
    })

    this.ast.program.body.unshift(...this.imports)
  }

  getAliasesUsed(){
    return _.uniq(this.classes.reduce((aliases, cls) => ([...aliases, ...cls.getAliasesUsed()]), []))
  }

  getClassNamesUsed(){
    let internalCls = this.classes.map(cls => cls.className),
        externalCls = SourceFile.classRe.reduce((classes, re) => [...classes, ...(this._getMatches(re).map(match => match[1]))], [])

    return _.uniq(externalCls.filter(cls => !internalCls.includes(cls)))
  }

  _getMatches(regExp){
    let matches = [],
        match

    while(match = regExp.exec(this.source)){
      matches.push(match)
    }

    return matches
  }

  process(){
    let isIdentifier = node => namedTypes.Identifier.check(node),
        isString     = node => namedTypes.Literal.check(node),
        isObject     = node => namedTypes.ObjectExpression.check(node)

    let getMethodCall = node => {
      let { object, property } = node.callee
      return (isIdentifier(object) && isIdentifier(property)) ? `${object.name}.${property.name}` : null
    }

    let processImport = node => this.imports.push(node)

    let processClassDefinition = node => {
      let [className, data, createdFn] = node.arguments

      if(!isString(className) || !isObject(data)){
        logError(`Error parsing Ext.define call (${this.filePath}): Expected first and second arguments to be a string and object, respectively`)
        return
      }

      this.classes.push(new ExtJSClass(this, className.value, data, createdFn))
    }

    visit(this.ast, {
      visitImportDeclaration: function(path){
        processImport(path.node)
        this.traverse(path)
      },

      visitCallExpression: function(path){
        let { node } = path

        if(getMethodCall(node) === 'Ext.define'){
          processClassDefinition(node)
        }

        this.traverse(path)
      }
    })
  }
}